def get_word(sentence, n):
	# Only proceed if n is positive
	if n > 0:
		words = sentence.split()
		# Only proceed if n is not more than the number of words
		if n <= len(words):
			return(words[n-1])
	return("")

print(get_word("This is a lesson about lists", 4)) # Should print: lesson
print(get_word("This is a lesson about lists", -4)) # Nothing
print(get_word("Now we are cooking!", 1)) # Should print: Now
print(get_word("Now we are cooking!", 5)) # Nothing

List Defined
Lists in Python are defined using square brackets, with the elements stored in the list separated by commas: list = ["This", "is", "a", "list"]
You can use the len() function to return the number of elements in a list: len(list) would return 4.
In Python, lists and strings are quite similar. Theyâ€™re both examples of sequences of data.

Modifying Lists

def skip_elements(elements):
	# Initialize variables
	new_list = []
	i = 0

	# Iterate through the list
	for elem in elements:
		# Does this element belong in the resulting list?
		if i % 2 == 0:
			# Add this element to the resulting list
			new_list.append(elem)
		# Increment i
		i += 1

	return new_list

print(skip_elements(["a", "b", "c", "d", "e", "f", "g"])) # Should be ['a', 'c', 'e', 'g']
print(skip_elements(['Orange', 'Pineapple', 'Strawberry', 'Kiwi', 'Peach'])) # Should be ['Orange', 'Strawberry', 'Peach']
print(skip_elements([])) # Should be []

List and Tuples

Tuples can be useful when we need to ensure that an element is in a certain position and will not change

def file_size(file_info):
	name, file_extension, bytes= file_info
	return("{:.2f}".format(bytes / 1024))

print(file_size(('Class Assignment', 'docx', 17875))) # Should print 17.46
print(file_size(('Notes', 'txt', 496))) # Should print 0.48
print(file_size(('Program', 'py', 1239))) # Should print 1.21


def skip_elements(elements):
    # code goes here
    list = []
    for index,element in enumerate(elements):
        if index % 2 == 0:
            list.insert(index, element)
    return list

print(skip_elements(["a", "b", "c", "d", "e", "f", "g"])) # Should be ['a', 'c', 'e', 'g']
print(skip_elements(['Orange', 'Pineapple', 'Strawberry', 'Kiwi', 'Peach'])) # Should be ['Orange', 'Strawberry', 'Peach']

Iterating Over Lists Using Enumerate
ou can do this using the enumerate() function. The enumerate() function takes a list as a parameter and returns a tuple for each element in the list.
The first value of the tuple is the index and the second value is the element itself.


def odd_numbers(n):
	return [x for x in range(0, n+1) if x%2 != 0]

print(odd_numbers(5))  # Should print [1, 3, 5]
print(odd_numbers(10)) # Should print [1, 3, 5, 7, 9]
print(odd_numbers(11)) # Should print [1, 3, 5, 7, 9, 11]
print(odd_numbers(1))  # Should print [1]
print(odd_numbers(-1)) # Should print []

List Comprehensions
List comprehensions allow you to create a new list from a sequence or a range in a single line.
For example, [ x*2 for x in range(1,11) ] is a simple list comprehension.

Lists and Tuples Operations Cheat Sheet
Lists and Tuples Operations Cheat Sheet
Lists and tuples are both sequences, so they share a number of sequence operations. But, because lists are mutable, there are also a number of methods specific just to lists. This cheat sheet gives you a run down of the common operations first, and the list-specific operations second.

Common sequence operations
len(sequence) - Returns the length of the sequence

for element in sequence - Iterates over each element in the sequence

if element in sequence - Checks whether the element is part of the sequence

sequence[i] - Accesses the element at index i of the sequence, starting at zero

sequence[i:j] - Accesses a slice starting at index i, ending at index j-1. If i is omitted, it's 0 by default. If j is omitted, it's len(sequence) by default.

for index, element in enumerate(sequence) - Iterates over both the indexes and the elements in the sequence at the same time

 Check out the official documentation for sequence operations.

List-specific operations and methods
list[i] = x - Replaces the element at index i with x

list.append(x) - Inserts x at the end of the list

list.insert(i, x) - Inserts x at index i

list.pop(i) - Returns the element a index i, also removing it from the list. If i is omitted, the last element is returned and removed.

list.remove(x) - Removes the first occurrence of x in the list

list.sort() - Sorts the items in the list

list.reverse() - Reverses the order of items of the list

list.clear() - Removes all the items of the list

list.copy() - Creates a copy of the list

list.extend(other_list) - Appends all the elements of other_list at the end of list

 Most of these methods come from the fact that lists are mutable sequences. For more info, see the official documentation for mutable sequences and the list specific documentation.

List comprehension
[expression for variable in sequence] - Creates a new list based on the given sequence. Each element is the result of the given expression.

[expression for variable in sequence if condition] - Creates a new list based on the given sequence. Each element is the result of the given expression; elements only get added if the condition is true.  